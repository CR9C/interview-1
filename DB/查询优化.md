>对查询进行优化，应尽量避免全表扫描，首先考虑是在 where 及 order by 涉及的列上建立索引。

###使用索引的角度
- 索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率 特别是数据量大的表
- 一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要
- 关于索引的选择，应该主意：
	- 根据数据量决定哪些表需要增加索引，数据量小的可以只有主键。
	- 根据使用频率决定哪些字段需要建立索引，选择经常作为连接条件、筛选条件、聚合查询、排序的字段作为索引的候选字段。
	- 把经常一起出现的字段组合在一起，组成组合索引，组合索引的字段顺序与主键一样，也需要把最常用的字段放在前面，把重复率低的字段放在前面。
	- 一个表不要加太多索引，因为索引影响插入和更新的速度。
	
###字段设计
- 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。  
这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。  
- 尽可能的使用varchar/nvarchar代替char/nchar，因为首先变长字段存储空间小，可以节省存储空间；  
其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。  
- 字段是数据库最基本的单位，其设计对性能的影响是很大的。需要注意如下：
	- 数据类型尽量用数字型，数字型的比较比字符型的快很多。
	- 数据类型尽量小，这里的尽量小是指在满足可以预见的未来需求的前提下的。
	- 尽量不要允许NULL，除非必要，可以用NOT NULL+DEFAULT代替。
	- 少用TEXT和IMAGE，二进制字段的读写是比较慢的，而且，读取的方法也不多，大部分情况下最好不用。
	- #自增字段#要慎用，不利于数据迁移。

###外键的设计
>外键作为数据库对象，很多人认为麻烦而不用，实际上，外键在大部分情况下是很有用的，理由是：  
外键是最高效的一致性维护方法，数据库的一致性要求，依次可以用:  
[外键>CHECK约束>规则约束>触发器>客户端程序]，一般认为，离数据越近的方法效率越高。  
谨慎使用级联删除和级联更新，级联删除和级联更新作为SQL SERVER 2000当年的新功能，在2005作了保留，应该有其可用之处。我这里说的谨慎，是因为级联删除和级联更新有些突破了传统的关于外键的定义，功能有点太过强大，使用前必须确定自己已经把握好其功能范围，否则，级联删除和级联更新可能让你的数据莫名其妙的被修改或者丢失。从性能看级联删除和级联更新是比其他方法更高效的方法。  

###系统设计
- 整个系统的设计特别是系统结构设计对性能是有很大影响的，对于一般的OLTP系统，可以选择C/S结构、三层的C/S结构等，不同的系统结构其性能的关键也有所不同。  
系统设计阶段应该归纳一些业务逻辑放在数据库编程实现，数据库编程包括"数据库存储过程、触发器和函数"。  
用数据库编程实现业务逻辑的好处是减少网络流量并可更充分利用数据库的预编译和缓存功能。  
- 合理的冗余  
完全按照规范化设计的系统几乎是不可能的，除非系统特别的小，在规范化设计后，有计划地加入冗余是必要的。  
冗余可以是冗余数据库、冗余表或者冗余字段，不同粒度的冗余可以起到不同的作用。  
冗余可以是为了编程方便而增加，也可以是为了性能的提高而增加。  	
从性能角度来说:  
冗余数据库可以分散数据库压力，  
冗余表可以分散数据量大的表的并发压力，也可以加快特殊查询的速度，  
冗余字段可以有效减少数据库表的连接，提高效率。  

###存储过程
>在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF。  
无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。  

###业务和事务操作角度
- 尽量避免大事务操作，提高系统并发能力。
- 尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。

###临时表
- 尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。
- 避免频繁创建和删除临时表，以减少系统表资源的消耗。
- 临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。
- 在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。
- 如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。

  



















