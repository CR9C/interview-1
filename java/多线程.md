###如果做 java web 方面开发的话几乎用不到多线程！因为有多线程的地方 servlet 容器或者其他开发框架都已经实现掉了！
>一般在网络应用程序中使用多线程的地方非常多！
以多线程来提高效率的场景一般在 CPU 计算型，而不是在 IO 读写型。CPU 可以会有多个核心并行处理计算，但是磁盘 IO 就没这功能了，磁头只有一个，根本不可能靠多线程提高效率！
 一般来说，磁盘 IO 的并发能力为 0，也就是说无法支持并发！网络 IO 的话由于带宽的限制的，使用多线程处理最多也只能达到带宽的极值。
 对于磁盘 IO 来说，多线程可以用于一个线程专门用于读写文件，其他的线程用于对读取数据进行处理，这样才有可能更好地利用 CPU 资源。
还有一种极为普遍的使用多线程的场景是UI编程,一般UI界面绘制于主线程,为了不阻塞主线程让用户体验更流畅,需要创建单独的线程处理耗时操作,处理完了再更新主界面,典型的案例就是android应用开发 

###常见面试题
线程的基本概念、线程的基本状态及状态之间的关系？  
>线程，有时称为轻量级进程，是CPU使用的基本单元；它由线程ID、程序计数器、寄存器集合和堆栈组成。它与属于同一进程的其他线程共享其代码段、数据段和其他操作系统资源（如打开文件和信号）。
线程有四种状态：新生状态、可运行状态、被阻塞状态、死亡状态。

- 新生（New）：  
	线程对象已经产生，但尚未被启动，所以无法执行。如通过new产生了一个线程对象后没对它调用start()函数之前。 
- 可执行（Runnable）：  
	每个支持多线程的系统都有一个排程器，排程器会从线程池中选择一个线程并启动它。当一个线程处于可执行状态时，表示它可能正处于线程池中等待排排程器启动它；也可能它已正在执行。如执行了一个线程对象的start()方法后，线程就处于可执行状态，但显而易见的是此时线程不一定正在执行中。
- 死亡（Dead）：  
	当一个线程正常结束，它便处于死亡状态。如一个线程的run()函数执行完毕后线程就进入死亡状态。
- 停滞（Blocked）：  
	当一个线程处于停滞状态时，系统排程器就会忽略它，不对它进行排程。

###线程与进程的区别？
- 线程是进程的一部分，所以线程有的时候被称为是轻权进程或者轻量级进程。
- 一个没有线程的进程是可以被看作单线程的，如果一个进程内拥有多个进程，进程的执行过程不是一条线（线程）的，而是多条线（线程）共同完成的
- 系统在运行的时候会为每个进程分配不同的内存区域，但是不会为线程分配内存（线程所使用的资源是它所属的进程的资源），线程组只能共享资源。那就是说，出了CPU之外（线程在运行的时候要占用CPU资源），计算机内部的软硬件资源的分配与线程无关，线程只能共享它所属进程的资源。
- 与进程的控制表PCB相似，线程也有自己的控制表TCB，但是TCB中所保存的线程状态比PCB表中少多了。
- 进程是系统所有资源分配时候的一个基本单位，拥有一个完整的虚拟空间地址，并不依赖线程而独立存在。

###多线程有几种实现方法，都是什么？
- 继承 Thread 类
- 实现 Runnable 接口再 new Thread(YourRunnableOjbect) 

###进程间通信
- 管道（Pipe）：  
	管道可用于具有亲缘关系进程间的通信，允许一个进程和另一个与它有共同祖先的进程之间进行通信。  
	管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。  
	进程的亲缘关系通常是指父子进程关系。
- 命名管道（named pipe）：  
	命名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。
- 信号（Signal）：  
	信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）。
- 消息（Message）队列：  
	消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺
- 共享内存：  
	使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。
- 内存映射（mapped memory）：  
	内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。
- 信号量（semaphore）：  
	主要作为进程间以及同一进程不同线程之间的同步手段。  
	信号允许多个线程同时使用共享资源 ，这与操作系统中的PV操作相同。  
	它指出了同时访问共享 资源的线程 最大数目。它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。
- 套接口（Socket）：  
	更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。

###java多线程间通信
- 共享变量
- 管道流  
	```
		PipedOutputStream pos = new PipedOutputStream();//创建管道输出流  
		PipedInputStream pis = new PipedInputStream();//创建管道输入流  
		pos.connect(pis);//将管道输入流与输出流连接 此过程也可通过重载的构造函数来实现  
		pos.write(i);
		pis.read();
	```

###[java实现同步](http://blog.csdn.net/escaflone/article/details/10418651#)
- 普通方式:
	1. synchronized关键字
	- Object类的wait、notify和notifyAll方法
- 高级方式：
	1. volatile
	- atomic包中提供的Java类(java.util.concurrent.atomic)
	- Lock(java.util.concurrent.locks)
	- 信号量:Semaphore
	- 倒数闸门:CountDownLatch
	- 循环屏障:CyclicBarrier
	- 对象交换器:Exchanger
	- 队列  
		BlockingQueue接口  
		BlockingDeque接口
	- 集合类  
		ConcurrentMap接口  
		CopyOnWriteArrayList接口
	- ThreadLocal类(java.lang.ThreadLocal)

###Lock和synchronized的区别
- Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；
- synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；
- Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；
- 通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。
- Lock可以提高多个线程进行读操作的效率。    
	在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。

###锁相关的概念
- 可重入锁  
	[链接](http://ifeve.com/java_lock_see4/)  
	可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后内层递归函数仍然有获取该锁的代码，但不受影响。  
	synchronized和ReentrantLock都是可重入锁.比如说method1，而在method1中会调用另外一个synchronized方法method2，此时线程不必重新去申请锁，而是可以直接执行方法method2

	```
	class MyClass {
	    public synchronized void method1() {
	        method2();
	    }
	    public synchronized void method2() {
	         
	    }
	}
	```
- 可中断锁  
	可中断锁：顾名思义，就是可以相应中断的锁。  
	在Java中，synchronized就不是可中断锁，而Lock是可中断锁。  
	如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。
- 公平锁  
	公平锁即尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该所，这种就是公平锁。  
	非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。在Java中，synchronized就是非公平锁，它无法保证等待的线程获取锁的顺序。  
- 读写锁  
	读写锁将对一个资源（比如文件）的访问分成了2个锁，一个读锁和一个写锁。    
	正因为有了读写锁，才使得多个线程之间的读操作不会发生冲突。    
	如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁。
- 自旋锁  
	[链接](http://ifeve.com/java_lock_see1/)  
	互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入到内核态中完成，这些操作给系统的并发带来了很大的压力。  
	很多时候，共享数据的锁定状态只会持续一段很短的时间，为了这段时间去挂起恢复线程并不值得，所以可以让等待的线程稍等一下，进行一个忙循环(自旋)，结束后就可以获得已经没有处于锁定状态的共享数据

	自旋锁是采用让当前线程不停地的在循环体内执行实现的，当循环的条件被其他线程改变时 才能进入临界区。如下
	```
	public class SpinLock {
 	private AtomicReference<Thread> sign =new AtomicReference<>();
  	public void lock(){
    Thread current = Thread.currentThread();
    while(!sign .compareAndSet(null, current)){
    	}
  	}
  	public void unlock (){
	    Thread current = Thread.currentThread();
	    sign .compareAndSet(current, null);
	  }
	}
	```
- 阻塞锁  
	[链接](http://ifeve.com/java_lock_see3/)  
	可以说是让线程进入阻塞状态进行等待，当获得相应的信号（唤醒，时间） 时，才可以进入线程的准备就绪状态，准备就绪状态的所有线程，通过竞争，进入运行状态。  
	JAVA中，能够进入\退出、阻塞状态或包含阻塞锁的方法有 ，synchronized 关键字（其中的重量锁），ReentrantLock，Object.wait()\notify(),LockSupport.park()/unpart()(j.u.c经常使用)  
- 互斥锁
	所谓互斥锁, 指的是一次最多只能有一个线程持有的锁。  
	在jdk1.5之前, 我们通常使用synchronized机制控制多个线程对共享资源的访问. 而现在, Lock提供了比synchronized机制更广泛的锁定操作
- 悲观锁  
	[乐观锁,悲观锁](http://www.cnblogs.com/alexlo/archive/2013/04/05/3000992.html)   
	它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。  
	悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系 统不会修改数据）
- 乐观锁    
	相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。  
	而乐观锁机制在一定程度上解决了这个问题。乐观锁，大多是基于数据版本（ Version ）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。  
	读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据
- 偏向锁   
	是Java6引入的一项多线程优化。它通过消除资源无竞争情况下的同步原语，进一步提高了程序的运行性能。  
	偏向锁，顾名思义，它会偏向于第一个访问锁的线程，如果在接下来的运行过程中，该锁没有被其他的线程访问，则持有偏向锁的线程将永远不需要触发同步。  
	如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会尝试消除它身上的偏向锁，将锁恢复到标准的轻量级锁。(偏向锁只能在单线程下起作用)因此 流程是这样的 偏向锁->轻量级锁->重量级锁 


###锁的状态及优化
[链接](http://www.cnblogs.com/paddix/p/5405678.html)
    
- 锁的状态
	- 无锁状态
	- 偏向锁
	- 轻量级锁
	- 重量级锁 
- 锁的优化
	- 适应性自旋  
	从轻量级锁获取的流程中我们知道，当线程在获取轻量级锁的过程中执行CAS操作失败时，是要通过自旋来获取重量级锁的。  
	问题在于，自旋是需要消耗CPU的，如果一直获取不到锁的话，那该线程就一直处在自旋状态，白白浪费CPU资源。解决这个问题最简单的办法就是指定自旋的次数，例如让其循环10次，如果还没获取到锁就进入阻塞状态。  
	但是JDK采用了更聪明的方式——适应性自旋，简单来说就是线程如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少。
	- 锁粗化  
	锁粗化的概念应该比较好理解，就是将多次连接在一起的加锁、解锁操作合并为一次，将多个连续的锁扩展成一个范围更大的锁。举个例子： 
	```
	package com.paddx.test.string;
  	public class StringBufferTest {
	    StringBuffer stringBuffer = new StringBuffer();
	 	public void append(){
		     stringBuffer.append("a");
		     stringBuffer.append("b");
		     stringBuffer.append("c");
	     }
 	} 
	```
	这里每次调用stringBuffer.append方法都需要加锁和解锁，如果虚拟机检测到有一系列连串的对同一个对象加锁和解锁操作，就会将其合并成一次范围更大的加锁和解锁操作，即在第一次append方法时进行加锁，最后一次append方法结束后进行解锁
	- 锁消除  
	锁消除即删除不必要的加锁操作。根据代码逃逸技术，如果判断到一段代码中，堆上的数据不会逃逸出当前线程，那么可以认为这段代码是线程安全的，不必要加锁。  
	看下面这段程序：
	```
	public class SynchronizedTest02 {
	    public static void main(String[] args) {
	        SynchronizedTest02 test02 = new SynchronizedTest02();
	        //启动预热
	        for (int i = 0; i < 10000; i++) {
	            i++;
	        }
	        long start = System.currentTimeMillis();
	        for (int i = 0; i < 100000000; i++) {
	            test02.append("abc", "def");
	        }
	        System.out.println("Time=" + (System.currentTimeMillis() - start));
	    }

	    public void append(String str1, String str2) {
	        StringBuffer sb = new StringBuffer();
	        sb.append(str1).append(str2);
	    }
	}
	```
	虽然StringBuffer的append是一个同步方法，但是这段程序中的StringBuffer属于一个局部变量，并且不会从该方法中逃逸出去，所以其实这过程是线程安全的，可以将锁消除


###多线程同步和互斥有何异同，在什么情况下分别使用他们？举例说明。
>线程同步是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。  
线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步（下文统称为同步）。

###进程和线程的区别
>一个进程对应一个程序的执行，而一个线程则是进程执行过程中的一个单独的执行序列，一个进程可以包含多个线程。线程有时候也被称为轻量级进程.  
一个Java虚拟机的实例运行在一个单独的进程中，不同的线程共享Java虚拟机进程所属的堆内存。这也是为什么不同的线程可以访问同一个对象。线程彼此共享堆内存并保有他们自己独自的栈空间。这也是为什么当一个线程调用一个方法时，他的局部变量可以保证线程安全。但堆内存并不是线程安全的，必须通过显示的声明同步来确保线程安全。

###列举几种不同的创建线程的方法.  
	解答:可以通过如下几种方式：
- 继承Thread 类
- 实现Runnable 接口
- 使用Executor framework (这会创建一个线程池)

	通过线程池来创建更有效率。

###推荐通过哪种方式创建线程，为什么?
>解答：最好使用Runnable接口，这样你的类就不必继承Thread类.  
不然当你需要多重继承的时候，你将一筹莫展（我们都知道Java中的类只能继承自一个类，但可以同时实现多个接口）。  
在上面的例子中，因为我们要继承Base类，所以实现Runnable接口成了显而易见的选择。  
同时你也要注意到在不同的例子中，线程是如何启动的。  
按照面向对象的方法论，你应该只在希望改变父类的行为的时候才去继承他。  
通过实现Runnable接口来代替继承Thread类可以告诉使用者Counter是Base类型的一个对象，并会作为线程执行。  

###简要的说明一下高级线程状态.
- 解答：下图说明了线程的各种状态.

	1. 可执行(Runnable)：  
		当调用start()方法后，一个线程变为可执行状态，但是并不意味着他会立刻开始真正地执行。而是被放入线程池，由线程调度器根据线程优先级决定何时挂起执行。
	- 执行中(Running)：  
		处理器已经在执行线程的代码。他会一直运行直到被阻断，或者通过静态方法Thread.yield()自行放弃执行的机会，考虑到场景切换所带来的开销，yield()方法不应该被经常调用。
	- 等待中(Waiting)：  
		线程由于等待I/O等外部进程的处理结果而处于被阻断的状态，调用currObject.wait( )方法会使得当前线程进入等待状态，直到其它线程调用currObject.notify() 或者currObject.notifyAll() 。
	- 睡眠中(Sleeping)：  
		重载方法Thread.sleep(milliseconds)，Thread.sleep(milliseconds， nanoseconds)可以迫使Java线程进入睡眠状态（挂起）。

-  变化原因
	-  由于I/O阻塞（Blocked on I/O）：当I/O条件发生变化时（例如读取了几个字节的数据）会迁移到可执行状态。
	-  由于同步阻塞中（Blocked on synchronization）:   
		当获取锁之后会进入执行中状态。Thread.State  枚举类型包含了Java虚拟机支持的全部的线程状态类型，下面几点Java的线程宗旨确保了这些线程状态成为可能。
	- 对象可以被任何线程共享和修改。
	- 线程调度器的抢占性特性，使得线程可以随时在/不在多核处理之间切换处理器内核，这意味着方法可以在执行的过程中切换状态。否则方法中的死循环将永远阻塞CPU，并且使得不同线程的其他方法始终得不到执行。
	- 为了防止线程安全问题，那些脆弱的方法或者代码块可以被锁定。这使得线程可以处于被锁定或者加锁请求处理中两种状态。
	- 线程在处理I/O资源（如Sockets，文件句柄，数据库连接等）时会进入等待状态，
	- 处于I/O读写中的线程不能被切换，因此他们或者以成功/失败的结果正常完成处理，或者其它线程关闭了相应的资源，迫使他进入死亡或者完成的状态。这也是为什么一个合理的超时时间可以避免线程由于I/O处理而被永远阻塞，从而导致严重的性能问题。
	- 线程可以进入睡眠状态，以使得其他处于等待状态的线程有机会执行。

###yield和sleeping有何区别，sleep()和wait()有何区别？
>当一个任务调用了yield()方法，它将从执行中状态转变为可执行。而当一个任务调用了sleep()，则将从执行中状态转变为等待中/睡眠中状态。
方法wait(1000)使得当前线程睡眠1秒钟，但调用notify() 或者notifyAll()会随时唤醒线程。而sleep(1000)则会导致当前线程休眠1秒钟。

###为什么为了线程安全而锁定一个方法或者一个代码块称为“同步”而不是“锁定”或者“被锁定”
>当某个方法或者代码块被声明为”synchronized”后，保存数据的内存空间（例如堆内存）将保持被同步状态。
这意味着：当一个线程获取锁并且执行到已被声明为synchronized的方法或者代码块时，该线程首先从主堆内存空间中读取该锁定对象的所有变化，以确保其在开始执行之前拥有最新的信息。
在synchronized部分执行完毕，线程准备释放锁的时候，所有针对被锁定对象的修改都将为写入主堆内存中。这样其他线程在请求锁的时候就可以获取最新的信息。

###线程如何进行的同步处理？你可以列举出那些同步级别？同步方法和代码块如何区别？
>在Java语言中，每个对象都有一个锁，一个线程可以通过关键字synchronized来申请获取某个对象的锁.
关键字synchronized可以被用于方法（粗粒度锁，对性能影响较大）或代码块（细粒度锁）级别。  
锁定方法往往不是一个很好的选择，取而代之的我们应该只锁定那些访问共享资源的代码块.    
因为每一个对象都有一个锁，所以可以通过创建虚拟对象来实现代码块级别的同步，方法块级别的锁比锁定整个方法更有效。  
Java虚拟机灵活的使用锁和监视器，一个监视器总体来说就是一个守卫者，他负责确保只有一个线程会在同一时间执行被同步的代码。    
每个监视器对应一个对象的引用，在线程执行代码块的第一条指令之前，他必须持有该引用对象的锁，否则他将无法执行这段代码。  
一旦他获得锁，该线程就可以进入这段受到保护的代码。  
当线程不论以何种方式退出代码块时，他都将释放关联对象的锁。对于静态方法，需要请求类级别的锁。