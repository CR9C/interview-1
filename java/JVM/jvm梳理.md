[TOC]
#Java内存区域与溢出异常

溢出异常主要分为StackOverflowError和OutOfMemoryError,StackOverflowError主要发生在Java虚拟栈中，对于无法动态扩展栈深度的虚拟机来说，如果线程请求的栈深度大于JVM所允许的深度，将会抛出这个异常。对于可以扩大虚拟机栈深度的JVM来说，如果扩展时无法申请到足够的空间，则会抛出OutOfMemoryError
##运行时数据区域
Java虚拟机锁管理的内存将会包括以下几个运行时数据区：程序计数器，Java虚拟栈，本地方法栈，方法区，堆(heap)。
###程序计数器
他可以看做是当前线程所执行的字节码的行号指令器。在任何一个确定的时刻，一个处理器(对于多核处理来说是一个内核)都只会执行一个线程中的指令。因此，为了线程切换后能够恢复到正确的执行位置，每条线程都需要有一个独立的PC。如果执行的是Native方法，这个计数器为空(Undefine)。此内存区域是唯一一个在虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

###Java虚拟机栈
与PC相同，也是私有的，他的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型，每个方法执行的同时都会创建一个栈帧，用于储存局部变量表，操作数栈，动态链表，方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中出入栈的过程。
局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部空间是完全确定的。在方法运行期间不会改变局部变量表的大小。
虚拟机栈会抛出StackOverflowError和OutOfMemoryError。

###本地方法栈
和Java虚拟栈类似，执行的是本地方法

###Java堆
Java堆是被所有线程共享的一块内存区域，几乎所有的对象实例都在这里分配内存。回收细节会在GC算法中描述。
主流虚拟机的Java堆都是被设计成可扩展的(通过-Xmx和-Xms控制)。如果在堆中没内存完成实例分配，并且堆也无法再扩展时，会抛出OutOfMemoryError异常。

###方法区
与Java堆一样，是各个线程共享的内存区域，他用于存储已被虚拟机加载的类信息，常亮，静态变量，即时编译器编译后的代码等数据。

###运行时常量池
Runtime Constant Pool是方法区的一部分。Class文件中除了有类的版本，字段，方法，接口等描述信息外，还有一项是常量池(Constant Pool Table）用于存放编译期间生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池存放。
常量池具有动态性，并非常量只有在编译期才能产生，运行期间也能将新的常量放入常量池中，如String类的intern()方法。

###直接内存
Direct Memory并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也频繁地被使用，也会引发OutOfMemoryError。
在JDK1.4中新加入了NIO，引入了一种基于通道(Channel)和缓冲区(Buffer)的I/O方式，可以使用Native函数库直接分配堆外内存，然后通过这个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，这样能在一些场景中避免在Java堆和Native堆中来回复制数据。

##对象的创建
虚拟机遇到一条New指令时，首先将去检查这个符号引用代表的类是否已经被加载，解析和初始化过，如果有，那必须先执行相应的类加载过程。
类加载检查通后，虚拟机将为新生对象分配内存，对象书序内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。
需要考虑的是，对象创建在虚拟机中是非常频繁地行为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的。
解决这个问题有两种方案
- 对分配内存空间的动作进行同步处理
- 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲(Thread Local Allocation Buffer，TLAB)。只有TLAB用完并分配新的TLAB时，才需要同步锁定。虚拟机是否使用TLAB，可以通过-XX:+/-UseTLAB参数来设定。

内存分配完成后，虚拟机将分配到的内存空间都初始化为零值，保证对象的实例字段在Java中不赋初值就可以直接使用，程序能访问到这些字段的数据类型所对应的零值。


##对象的内存布局
在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域，对象头，实例数据，和对齐填充。

##对象的访问定位
建立对象是为了访问对象，Java程序需要通过栈上的reference数据来操作堆上的具体对象。主流的访问方式有使用句柄和直接指针两种。
- 使用句柄，在堆中会划分出一块内存来作为句柄池，reference中存储的信息就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。
- 使用指针，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息。而reference中存储的直接就是对象地址。


#GC与内存分配策略
三个问题
- 哪些内存需要回收
- 什么时候回收
- 如何回收

##对象是否该被回收
###引用计数法(Reference Counting)
该算法实现简单，效率也很高，但是无法解决对象循环引用的问题。

###可达性分析算法
通过一系列的称为GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。

###几种引用
- 强引用 只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象。
- 软引用是用来描述一些还有用但非必须的对象。对于软引用关联的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。
- 弱引用 被弱引用关联的对象只能生存到下一次垃圾收集发生之前，当垃圾收集器工作时，无论当前内存是否足够，都会回收掉之被弱引用关联的对象。
- 虚引用 不会对对象的生存时间构成影响，亦无法通过虚引用来取得一个对象的实例。唯一目的就是在这个对象在收集器回收时能收到一个系统通知。

###回收方法区
在大量使用反射，动态代理，CGLib等ByteCode框架、动态生成JSP以及OSGi这里频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。

##垃圾收集算法
###标记-清除算法 (Mark-Sweep)
首先标记出需要回收的对象，在标记完成后统一回收所有被标记的对象。
主要不足有两个:
- 效率问题 标记和清除的效率都不高
- 空间问题 清除后会产生大量不连续的内存碎片

###复制算法
将可用内存容量划分为大小相等的两块，每次只使用其中的一块，当这一块的内存用完时，就将还存活的对象复制到另一块上面，然后再把已使用过的内存空间**一次清理掉**。

###标记-整理算法
根据老年代的特点，有人提出了一种标记整理(Mark-Compat)算法，标记过程仍然与“标记-清除”算法一样，但后续过程不是直接对可回收对象进行清理，而是让所有存活的对象都想一端移动，然后清理掉端便捷意外的内存。

###分代收算法
在新生代，每次垃圾收集都有大批对象死去，只有少量存活，那就选择复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高，没有额外空间对他进行分配担保，就必须使用***标记-清理***或是***标志整理***算法来进行回收。

##垃圾收集器

//TODO:待补充

##内存分配与回收策略
对象主要分配在新生代的Edne区上，如果启动了本地线程分配缓冲，则按线程优先在TLAB上分配，少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的。
###对象优先在Eden分配
对象在新生代Eden区分配，当Eden区没有足够内存进行分配时，虚拟机将发起一次Minor GC。
注意:Minor GC会将Eden区存活的对象移动到Survivor区，当Survivor区不足时，只能通过分配担保机制提前转移到老年代去。
大对象直接进入老年代 参数(-XX:PretenureSizeThreshold)，令大于这个设置值的对象直接在老年代分配。

###长期存活的对象进入老年代
如果对象在Eden出生并且经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设置为一，对象在Survivor区每熬过一次Minor GC，年龄就加一岁，当它的年龄增加到一定程度(默认为15岁，可以通过-XX:MaxTenuringThreshold设置)，就会被晋升到老年代中。


###空间分配担保
在发生Minor GC前，***虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，则可以锁Minor GC是安全的，如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC。如果小于，或者HandlePromotionFailure设置为不允许冒险，那这是要改为进行一次Full GC*** JDK6之后的规则变为，***只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC***。
