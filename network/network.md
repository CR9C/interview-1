#七层模型
- 物理层
- 数据链路层
- 网络层
- 传输层
- 会话层
- 表示层
- 应用层

#TCP相关
##TCP连接为什么需要三次握手
- 建立连接实际上是一个收发两方互相确认SYN号的过程，而每次确认都需要发送数据和接收ACK，因此最少需要两次SYN发送和ACK接收，TCP把第二次SYN发送和第一次SYN的ACK回复合并。如果变为两次握手，实际上就只有一方能够确认另一方的序列号，而另一方无法知道对方的SYN号，就不知道发过来的数据包是否正确，这就成为了一个单向通信的连接。
- 如果两次握手，客户端发送了请求，服务器进行ACK，就认为建立了一次双向链接的话，那么对于如下情况就会产生问题。如果有一次请求的报文因为阻塞在了某处，在发送方已经不需要连接的时候，该报文到达了接收方，接收方回复了ACK就认为已经建立了链接，开始发送消息，但是发送方收到了ACK，会断定该ACK是无效的，这样也不会接收后续的数据报，这样就浪费了接收方的资源，而三次握手就不会产生这样的情况。

#Cookie和Session
由于Http是无状态的协议，所以服务端需要记录用户的状态时，就需要通过某种机制来识别具体的用户，这种机制就是Session。服务端识别客户端，就需要Cookie的帮助了，每次HTTP请求，客户端都会发送相应的Cookie到服务端，实际上大多数应用都是通过Cookie来实现Session跟踪的，第一次创建Session的时候，服务端会告诉客户端，需要在Cookie中记录SessionID，以后每次请求把这个ID发送到服务端，服务端就知道客户端的身份了。
如果禁用了Cookie，可以使用URL重写的技术来进
行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个类似sid = xxx这样的参数，服务端据此来识别服务器。Cookie还可以把用户输入过的用户名密码存在本地，实现自动登录。

#交换机和路由器区别
路由器通过路由算法对数据报进行转发
交换机则是一种基于MAC地址识别，能完成封装转发数据报的设备


#DNS解析
1. 检查浏览器缓存中是否有对应的映射关系，如果有，结束
2. 如果没有，查看操作系统缓存中是否有映射关系
3. 若前两步都没有得到结果，则把域名发送给LocalDNS服务器，让LDNS解析
4. 若仍然没有命中，就到RootServer域名服务器解析
5. 根域名服务器返回给LDNS一个所查询的主域名服务器gDNS
6. LDNS再向GDNS请求
7. gTLD服务器查找并返回此域名对应的Name Server域名服务器的地址，这个Name Server通常就是用户注册的域名服务器，这个域名解析任务就由域名提供商的服务器来完成
8. Name Server域名服务器会查询储存的域名和关系映射表，得到目标IP地址后连同一个TTL返回给LDNS
9. 得到ip和TTL，LDNS会缓存这个域名和IP的对应关系，缓存时间由TTL来控制
10. 解析结果返回给用户主机，根据TTL缓存，解析结束

#HTTP协议
##报文结构
Request格式：
HTTP请求行 
请求头 
空行 
可选的消息体 

Response格式：
HTTP状态行 
应答头 
空行 
可选的消息体

##get和post的区别
get
>请求可以被缓存
请求保留在浏览器历史记录中
请求可被收藏为书签
请求不应在处理敏感数据时使用
请求长度有限制
请求只应当用于取回数据

post
>请求不会被缓存
请求不会保留在浏览器历史记录中
请求不能被收藏做书签

##HTTPS
Secure Hypertext Transfer Protocol 安全超文本传输协议，是使用TLS/SSL加密的HTTP协议。HTTP采用明文传输，存在窃听，篡改的风险，而TLS/SSL协议具有身份验证，信息加密和完整性校验等功能，可以避免这些问题的发生。

###TLS/SSL原理
实现主要依赖于三种算法，对称加密，非对称加密，HASH算法
利用非对称加密实现身份验证和密钥协商，对称加密采用协商的密钥对数据进行加密，基于散列的算法验证数据的完整性。
###握手过程
![握手过程](http://www.wxtlife.com/img/https/https_02.png)

- client hello 客户端发起请求，用明文传输版本信息，可用加密套件列表，压缩算法候选列表，随机数(客户端)等等
- server hello 服务端返回协商结果，包括选择使用的协议版本，选择的加密套件，选择的压缩算法，随机数(服务端)，随机数用于后续的密钥协商。还发送对应配置的证书链，用于身份验证。
- 证书验证 验证包括:可信性，是否吊销，是否过期，域名
- client\_key\_exchange+change\_cipher\_spec+encrypted\_handshake\_message 合法性验证通过后，客户端产生随机数字Pre-master，并用证书加密，发送给服务器，三个随机数即可得到密钥。客户端通知服务器后续的通信都采用协商的通信密钥和加密算法进行加密通信。最后结合之前所有通信参数的 hash 值与其它相关信息生成一段数据，采用协商密钥 session secret 与算法进行加密，然后发送给服务器用于数据与握手验证
- change\_\cipher\_\spec+encrypted\_\handshake\_\message 服务器用私钥解密加密的Pre-master数据，基于之前交换的两个明文随机数计算得到协商的密钥。计算之前收到信息的hash值，然后解密客户端发送的encrypted handshake message，验证数据和密钥完整性，验证完毕后，服务器同样发送change cipher spec告知客户端协商完成，服务器也结合所有的通信参数信息生成一段数据并采用协商密钥发送给客户端。
- 客户端计算所有接收信息的 hash 值，并采用协商密钥解密 encrypted\_handshake\_message，验证服务器发送的数据和密钥，验证通过则握手完成;之后通信遍使用协商的密钥


#Git原理
git中，所有文件内容都保存在git仓库的objects目录中。
每个文件都有一个sha-1来标识。git对象可分为四种类型

1. blob对象，只用来存放文件内容，没有如名称路径之类的其他信息
1. tree对象，对应着目录，tree的内容为blob对象的指针和其他子tree的指针，最顶层的tree就是一个项目的快照
1. commit对象，每一次commit都会产生一个新的对象，其中包含了指向顶层tree的指针，一个指向上一次commit对象的指针，还包含了commit的时间，作者，commit message等信息。
5. tag对象，一种特殊的commit对象